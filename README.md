# Y86-64 Pipeline Visualizer

An interactive web-based visualizer for a 5-stage pipelined Y86-64 CPU implemented in Verilog. Step through each clock cycle and inspect the instruction in every pipeline stage alongside the architectural register state.

> Y86-64 is the ISA from *Computer Systems: A Programmer's Perspective* by Bryant & O'Hallaron.

## Key Features
* **Cycle-by-Cycle Stepping:** Navigate the execution timeline forward and backward to see exactly how instructions progress.
* **Pipeline Staircase Timeline:** Visualize the "staircase" execution pattern across all 5 stages (Fetch, Decode, Execute, Memory, Writeback).
* **Data Forwarding Visualization:** See dynamic dependency arrows showing how the processor resolves data hazards via forwarding and bypassing.
* **Architectural State Inspector:** View total register file state with highlights on changed values.
* **Instruction Memory Hex Viewer:** Inspect the loaded binary program, tracing the PC as it fetches bytes.

## Tech Stack
* **Hardware:** Verilog (simulated via Icarus Verilog), waveform parsing via Node.js
* **Backend:** Node.js, Express (parses VCD traces & serves simulation API)
* **Frontend:** React, Vite, plain CSS (no heavy UI libraries for max performance)

## Project Structure

```
.
├── hardware/
│   ├── pipeline/
│   │   ├── src/     Verilog source files
│   │   ├── tb/      Testbenches
│   │   ├── sim/     VCD simulation traces
│   │   └── DATA_MEM.txt
│   └── sequential/
│       ├── src/     Verilog source files
│       ├── tb/      Testbenches
│       ├── sim/     VCD simulation traces
│       └── DATA_MEM.txt  REG_MEM.txt  CC_MEM.txt
├── backend/         Node.js/Express API — parses the VCD trace
└── frontend/        React/Vite visualizer UI
```

## Prerequisites

### Node.js v18+ (backend + frontend)

Install from [nodejs.org](https://nodejs.org) or your package manager.

---

### Icarus Verilog (hardware simulation, optional)

Only needed if you want to re-run the simulations yourself. The pre-generated `sim/proc.vcd` is included so the visualizer works out of the box.

**macOS**
```bash
brew install icarus-verilog
```

**Ubuntu / Debian**
```bash
sudo apt-get install iverilog
```

**Windows** — download the installer from [bleyer.org/icarus](http://bleyer.org/icarus/).

Verify: `iverilog -v` and `vvp -v` should both print a version line.

---

### GTKWave (optional — waveform viewer)

Useful for inspecting `.vcd` files directly.

**macOS**
```bash
brew install --cask gtkwave
```

**Ubuntu / Debian**
```bash
sudo apt-get install gtkwave
```

Open a trace: `gtkwave hardware/pipeline/sim/proc.vcd`

---

## Running Locally

**1. Install dependencies** (first time only)
```bash
cd backend && npm install && cd ../frontend && npm install && cd ..
```

**2. Start the backend** (port 3001)
```bash
cd backend && npm start
```

**3. Start the frontend** (port 5173)
```bash
cd frontend && npm run dev
```

Open [http://localhost:5173](http://localhost:5173), click **Load Simulation**, then use the playback controls to step through all 610 clock cycles.

## How It Works

1. The backend reads `hardware/pipeline/sim/proc.vcd` — a Value Change Dump generated by the Icarus Verilog simulation.
2. `vcdMapper.js` parses the VCD, tracking signal values and capturing a snapshot on every rising clock edge.
3. The frontend fetches the resulting JSON array of cycle snapshots and renders:
   - **Pipeline Diagram** — the instruction (by icode) in each of the five stages: Fetch, Decode, Execute, Memory, Writeback.
   - **Register File** — the current values of all 15 architectural registers (rax–r14).
   - **Playback controls** — step forward/back, play/pause at 200 ms/cycle, or scrub with the slider.

## Pipeline Stages & Y86-64 Icodes

| Stage | Signal | Icodes tracked |
|-------|--------|----------------|
| Fetch | `f_icode` | HALT, NOP, CMOVXX, IRMOVQ, RMMOVQ, MRMOVQ, OPQ, JXX, CALL, RET, PUSHQ, POPQ |
| Decode | `D_icode` | same |
| Execute | `E_icode` | same |
| Memory | `M_icode` | same |
| Writeback | `W_icode` | same |

## Hardware Commands

> All commands must be run from the hardware implementation's root directory (e.g. `hardware/pipeline/`) so that `$readmemh` can find the data files (`DATA_MEM.txt` etc.) at runtime.

### Pipelined CPU

```bash
cd hardware/pipeline

# Run full pipeline simulation → writes sim/proc.vcd
iverilog -o proc.vvp src/proc.v && vvp proc.vvp

# Individual module testbenches
iverilog -o fetch_tb.vvp   tb/fetch_tb.v   && vvp fetch_tb.vvp
iverilog -o decode_tb.vvp  tb/decode_tb.v  && vvp decode_tb.vvp
iverilog -o execute_tb.vvp tb/execute_tb.v && vvp execute_tb.vvp
iverilog -o memory_tb.vvp  tb/memory_tb.v  && vvp memory_tb.vvp
iverilog -o alu_tb.vvp     tb/alu_tb.v     && vvp alu_tb.vvp

# Sequential harness using pipeline stage modules → writes sim/seq.vcd
iverilog -o seq.vvp tb/seq.v && vvp seq.vvp
```

### Sequential CPU

```bash
cd hardware/sequential

# Run sequential simulation → writes sim/seq.vcd
iverilog -o seq.vvp src/seq.v && vvp seq.vvp

# Individual module testbenches
iverilog -o fetch_tb.vvp    tb/fetch_tb.v    && vvp fetch_tb.vvp
iverilog -o execute_tb.vvp  tb/execute_tb.v  && vvp execute_tb.vvp
iverilog -o memory_tb.vvp   tb/memory_tb.v   && vvp memory_tb.vvp
iverilog -o alu_tb.vvp      tb/alu_tb.v      && vvp alu_tb.vvp
iverilog -o register_tb.vvp tb/register_tb.v && vvp register_tb.vvp
```

> The backend also attempts to re-run the pipeline simulation automatically on each `/api/simulate` request if `iverilog` is in `PATH`. Without it, the pre-existing `sim/proc.vcd` is used.

## Roadmap & Future Enhancements
- [x] Base 5-Stage Pipeline Visualization
- [x] Register File Tracking
- [x] Data Forwarding & Bypassing UI
- [x] Instruction Memory Viewer
- [x] Pipeline Execution Timeline
- [ ] **Data Memory Hex Viewer:** Interactively view memory reads and writes.
- [ ] **Live Y86 Assembler:** Write assembly in the browser, compile it on the server, and instantly visualize the execution trace.
- [ ] **TinyC Compiler Integration:** Compile higher-level C code down to Y86 for visualization.